/**
 * Exhibit Cover Sheet Generator
 *
 * Generates professional cover sheets for exhibits with proper USCIS formatting
 */

import { PDFDocument, rgb, StandardFonts } from 'pdf-lib';

export interface ExhibitInfo {
  exhibitNumber: string; // e.g., "A", "B", "C", etc.
  criterionNumber?: string; // e.g., "1", "2", "3" for EB-1A
  title: string;
  description: string;
  url: string;
  archivedUrl?: string;
  pageCount?: number;
  dateGenerated: string;
}

/**
 * Generate a cover sheet PDF for an exhibit
 *
 * @param exhibit - Exhibit information
 * @returns PDF buffer
 */
export async function generateCoverSheet(exhibit: ExhibitInfo): Promise<Buffer> {
  const pdfDoc = await PDFDocument.create();
  const page = pdfDoc.addPage([612, 792]); // Standard letter size (8.5 x 11 inches)
  const { width, height } = page.getSize();

  // Fonts
  const boldFont = await pdfDoc.embedFont(StandardFonts.HelveticaBold);
  const regularFont = await pdfDoc.embedFont(StandardFonts.Helvetica);

  // Colors
  const black = rgb(0, 0, 0);
  const darkGray = rgb(0.3, 0.3, 0.3);

  // Layout constants
  const margin = 72; // 1 inch margins
  const lineHeight = 20;
  let yPosition = height - margin;

  // Title: "EXHIBIT [Letter]"
  const exhibitLabel = exhibit.criterionNumber
    ? `EXHIBIT [${exhibit.criterionNumber}]-${exhibit.exhibitNumber}`
    : `EXHIBIT ${exhibit.exhibitNumber}`;

  page.drawText(exhibitLabel, {
    x: margin,
    y: yPosition,
    size: 24,
    font: boldFont,
    color: black,
  });
  yPosition -= lineHeight * 2;

  // Horizontal line
  page.drawLine({
    start: { x: margin, y: yPosition },
    end: { x: width - margin, y: yPosition },
    thickness: 2,
    color: black,
  });
  yPosition -= lineHeight * 1.5;

  // Title
  page.drawText('Title:', {
    x: margin,
    y: yPosition,
    size: 12,
    font: boldFont,
    color: black,
  });
  yPosition -= lineHeight;

  // Wrap title text if too long
  const titleLines = wrapText(exhibit.title, width - (margin * 2), 11, regularFont);
  for (const line of titleLines) {
    page.drawText(line, {
      x: margin + 20,
      y: yPosition,
      size: 11,
      font: regularFont,
      color: darkGray,
    });
    yPosition -= lineHeight * 0.9;
  }
  yPosition -= lineHeight * 0.5;

  // Description
  page.drawText('Description:', {
    x: margin,
    y: yPosition,
    size: 12,
    font: boldFont,
    color: black,
  });
  yPosition -= lineHeight;

  const descLines = wrapText(exhibit.description, width - (margin * 2), 11, regularFont);
  for (const line of descLines) {
    page.drawText(line, {
      x: margin + 20,
      y: yPosition,
      size: 11,
      font: regularFont,
      color: darkGray,
    });
    yPosition -= lineHeight * 0.9;
  }
  yPosition -= lineHeight * 0.5;

  // Original URL
  page.drawText('Original URL:', {
    x: margin,
    y: yPosition,
    size: 12,
    font: boldFont,
    color: black,
  });
  yPosition -= lineHeight;

  const urlLines = wrapText(exhibit.url, width - (margin * 2), 9, regularFont);
  for (const line of urlLines) {
    page.drawText(line, {
      x: margin + 20,
      y: yPosition,
      size: 9,
      font: regularFont,
      color: rgb(0, 0, 0.8), // Blue for URLs
    });
    yPosition -= lineHeight * 0.8;
  }
  yPosition -= lineHeight * 0.5;

  // Archived URL (if available)
  if (exhibit.archivedUrl) {
    page.drawText('Archived URL (Wayback Machine):', {
      x: margin,
      y: yPosition,
      size: 12,
      font: boldFont,
      color: black,
    });
    yPosition -= lineHeight;

    const archivedLines = wrapText(exhibit.archivedUrl, width - (margin * 2), 9, regularFont);
    for (const line of archivedLines) {
      page.drawText(line, {
        x: margin + 20,
        y: yPosition,
        size: 9,
        font: regularFont,
        color: rgb(0, 0, 0.8),
      });
      yPosition -= lineHeight * 0.8;
    }
    yPosition -= lineHeight * 0.5;
  }

  // Page count
  if (exhibit.pageCount) {
    page.drawText(`Pages in this exhibit: ${exhibit.pageCount}`, {
      x: margin,
      y: yPosition,
      size: 11,
      font: regularFont,
      color: darkGray,
    });
    yPosition -= lineHeight * 1.5;
  }

  // Date generated
  page.drawText(`Generated: ${exhibit.dateGenerated}`, {
    x: margin,
    y: yPosition,
    size: 10,
    font: regularFont,
    color: darkGray,
  });

  // Footer
  const footerY = margin / 2;
  page.drawText('Generated by Visa Petition Generator', {
    x: width / 2 - 100,
    y: footerY,
    size: 8,
    font: regularFont,
    color: rgb(0.5, 0.5, 0.5),
  });

  const pdfBytes = await pdfDoc.save();
  return Buffer.from(pdfBytes);
}

/**
 * Wrap text to fit within a maximum width
 */
function wrapText(text: string, maxWidth: number, fontSize: number, font: any): string[] {
  const words = text.split(' ');
  const lines: string[] = [];
  let currentLine = '';

  for (const word of words) {
    const testLine = currentLine ? `${currentLine} ${word}` : word;
    const testWidth = font.widthOfTextAtSize(testLine, fontSize);

    if (testWidth > maxWidth && currentLine) {
      lines.push(currentLine);
      currentLine = word;
    } else {
      currentLine = testLine;
    }
  }

  if (currentLine) {
    lines.push(currentLine);
  }

  return lines;
}

/**
 * Generate cover sheets for multiple exhibits
 */
export async function generateCoverSheets(
  exhibits: ExhibitInfo[]
): Promise<Map<string, Buffer>> {
  const coverSheets = new Map<string, Buffer>();

  for (const exhibit of exhibits) {
    const coverSheet = await generateCoverSheet(exhibit);
    const key = exhibit.criterionNumber
      ? `${exhibit.criterionNumber}-${exhibit.exhibitNumber}`
      : exhibit.exhibitNumber;
    coverSheets.set(key, coverSheet);
  }

  return coverSheets;
}
